---
title: "Mapping TTC Delays: Data Wrangling & Initial EDA"
author: "Lucie Yang"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
link-citations: yes
output: 
  github_document
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(eval = F, include  = T)

library(tidyverse)
library(sf)
library(stringr)
library(dplyr)
library(janitor)
library(scales)
```

First get the cleaned data (ttc_subway_delay.csv) from `data_cleaning.R`. The start this pipeline.

# Data Wrangling
```{r, warning = FALSE}
# library(readxl)
# library(readr)
# download.file("https://ckan0.cf.opendata.inter.prod-toronto.ca/dataset/996cfe8d-fb35-40ce-b569-698d51fc683b/resource/2ee1a65c-da06-4ad1-bdfb-b1a57701e46a/download/ttc-subway-delay-data-2024.xlsx",
#               "data/raw/subway_delay_2024.xlsx", mode = "wb")
# subway_delay_2024 <- read_excel("../ttc-subway-delay-data-2024.xlsx")
```

```{r}
subway_delay_2024 <- read_csv("ttc_subway_delay.csv")
```

```{r}
dim(subway_delay_2024)
```

For simplicity, only keep the delays that are at one station (not in between or multiple stations)
```{r}
subway_subset <- subway_delay_2024 %>%
  filter(str_detect(station, "STATION")) 
```

```{r}
dim(subway_subset) # nice! most of them are kept
```

Clean the text for the stations so I can join. 
```{r}
subway_subset$station <- str_remove(subway_subset$station, " STATION$") # remove STATION
subway_subset$station <- str_remove(subway_subset$station, " BD$") # remove BD
subway_subset$station <- str_remove(subway_subset$station, " YUS$") # remove YUS
subway_subset$station <- str_to_title(subway_subset$station) # change to title case
```

```{r}
sort(table(subway_subset$station), decreasing = TRUE) # weird names that will get messed up
```
There's some stations here that will definitely get lost in the join with the ESRI data -- some stations have been renamed/merged, some formatting/abbreviation differences, and some are misspellings. For example, Spadina YUS Station, Bloor Station, St Geoge (?!)

Manually rename these subway stations to match the ESRI data
```{r}
subway_subset <- subway_subset %>% 
  mutate(station = recode(station,
                          "Vaughan Mc" = "Vaughan Met. Centre",
                          "North York Ctr" = "North York Centre",
                          "St Geoge" = "St George",
                          "St. George" = "St George",
                          "Kenndy" = "Kennedy",
                          "Queens Park" = "Queen's Park",
                          "Old Mills" = "Old Mill",
                          "St. Andrew" = "St Andrew",
                          "Spadina Yu" = "Spadina",
                          "Sheppard Yonge" = "Sheppard",
                          "Wislon" = "Wilson",
                          "Sheppard-Yonge" = "Sheppard",
                          "Main Street" = "Main"))
```

```{r}
write.csv(subway_subset, "cleaned_delay_stations.csv", row.names = TRUE) # export
```

In ArcGIS Pro, I imported ESRI Canada Education's [Toronto Subway Stations point data](https://www.arcgis.com/home/item.html?id=05200e06ff524319bde9f16e5955496b). 
Then do the following geoprocessing to obtain `ttc-station-point.csv`: Geodatabase to Shape, Add XY Coordinates, Export Table.
```{r}
# grab nice TTC Station coordinates from ESRI ArcGIS
ttc_coords <- read_csv("ttc-station-point.csv")
```

Even though Bloor and Yonge are in the same location (and same point on the ESRI data), let's add them separately since the delays on the different lines are somewhat independent
```{r}
ttc_coords <- ttc_coords %>%
  # Filter the "Bloor-Yonge" row
  bind_rows(
    ttc_coords %>%
      filter(station == "Bloor-Yonge") %>%
      mutate(station = "Bloor",
             line = "Bloor-Danforth",
             line_1 = 2,
             POINT_Y = 43.6700, # slightly offset so they can be distinguished on the plot
             POINT_X = -79.3852
             ),
    ttc_coords %>%
      filter(station == "Bloor-Yonge") %>%
      mutate(station = "Yonge")
  ) %>%
  # remove the original "Bloor-Yonge" row
  filter(station != "Bloor-Yonge")

ttc_coords
```

Merge the XY coordinates to the delay data
```{r}
delay_coords <- left_join(subway_subset, ttc_coords, by = "station")
delay_coords
```

See what other stations are mismatched and continue to iterate and rerun
```{r}
mismatched <- delay_coords %>% filter(is.na(POINT_X))
sort(table(mismatched$station), decreasing = TRUE)
```
OK. Great, it seems like it is all the multiple stations / between stations now. So, let's remove them and now we can continue with the join!! 
```{r}
matched <- delay_coords %>% filter(!is.na(POINT_X))
```

Merge with the delay codes
```{r}
delay_codes <- read_csv("subway-delay-codes.csv")
delay_codes <- delay_codes %>% janitor::clean_names()
# final <- left_join(matched, delay_codes, by = join_by(code == sub_rmenu_code))
# final <- final %>% select(!number)
# final
```

```{r}
# write.csv(final, "cleaned_delay_stations.csv", row.names = TRUE) # export
```

Group by station
```{r}
# function to calculate mode
get_mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]  # return the most frequent value
}
```

```{r}
by_station <- final %>%
  group_by(station) %>%
  summarize(
    avg_delay = mean(min_delay, na.rm = TRUE),
    num_delays = n(),
    lon = first(POINT_X), # first is ok, because they are all the same for each station
    lat = first(POINT_Y),
    most_frequent_code = get_mode(code),
    freq_count = sum(code == most_frequent_code)
      )

by_station <- by_station %>% 
  left_join(delay_codes, by = join_by(most_frequent_code == sub_rmenu_code))

by_station
```

# Mapping!!

Read in the shapefile of the TTC Subway lines (from [Toronto Open Data](https://open.toronto.ca/dataset/ttc-subway-shapefiles/)). 
```{r}
my_sf <- read_sf("TTC_SUBWAY_LINES_WGS84.shp")
```

Plot the map!!!
```{r}
pal <- colorNumeric(
  palette = c("salmon", "purple", "blue"),
  # palette = "magma",
  domain = by_station$num_delays
)

leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolylines(data = my_sf, 
               color = ~case_when(
                 RID == 1 ~ "darkgoldenrod",      
                 RID == 2 ~ "darkgreen",    
                 RID == 4 ~ "purple", 
                 # TRUE ~ "gray"  # Default color for other lines if not specified
               ),
               weight = 5, opacity = 0.5) %>% 

  addCircleMarkers(
    data = by_station,
    lng = ~lon, lat = ~lat, 
    color = ~pal(num_delays),
    fillOpacity = 0.8,
    radius = ~rescale(num_delays, to = c(1, 10)),
    popup = ~paste0("<b>", station, "</b><br>Number of Delays: ", num_delays, 
                    "<br> Average Delay: ", round(avg_delay, 2), 
                    " minutes <br> Most Frequent Reason: ", code_description, 
                    " (", freq_count, ")")
  ) %>%
  
  addLegend(pal = pal, 
            values = by_station$num_delays,
            title = "Number of Delays",
            position = 'bottomright') %>% 
  addLegend(
    colors = c("darkgoldenrod", "darkgreen", "purple"),
    labels = c("1", "2", "4"),
    title = "Lines",
    position = 'topright'
  )
```

Another plot, combining the number and average delays, but this is harder to interpret.
```{r}
pal <- colorNumeric(
  palette = "Blues",
  domain = by_station$avg_delay
)

leaflet() %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%
  addPolylines(data = my_sf, color = "salmon", weight = 3, opacity = 0.8) %>%

  addCircleMarkers(
    data = by_station,
    lng = ~lon, lat = ~lat, 
    color = ~pal(avg_delay),
    fillOpacity = 0.6,
    radius = ~rescale(num_delays, to = c(2, 10)),
    popup = ~paste0("<b>", station, "</b><br>Number of Delays: ", num_delays, "<br> Average Delay: ", avg_delay)
  ) %>%
  
  addLegend(pal = pal, 
            values = by_station$avg_delay,
            title = "Average Delay Duration (minutes)",
            position = 'bottomright') %>% 
  
  addLegend(
    colors = c("lightblue", "lightblue", "lightblue"),  # Same color to simulate circle sizes
    labels = c("Small (5)", "Medium (15)", "Large (30)"),  # Custom labels for size range
    title = "Number of Delays", 
    position = 'bottomleft'
  )
```

That's interesting I guess. Onto the next steps!!
```{r}
write.csv(by_station, "delays_by_stations.csv", row.names = TRUE) # export
```

# Appendix: 
## Testing different ways to make maps (for fun)
```{r}
my_sf <- read_sf("TTC_SUBWAY_LINES_WGS84.shp")
```

```{r}
st_geometry(my_sf)
```
```{r}
my_sf <- st_transform(my_sf, crs = 4326)
```

```{r}
my_sf <- st_make_valid(my_sf)
```

```{r}
plot(st_geometry(my_sf))
```

```{r}
par(mar = c(0, 0, 0, 0))
plot(st_geometry(my_sf), col = "#f2f2f2", bg = "skyblue", lwd = 0.25, border = 0)
```

```{r}
library(ggplot2)
ggplot(my_sf) +
  geom_sf(fill = "#69b3a2", color = "red") +
  theme_void()
```

```{r}
my_sf <- st_transform(my_sf, 4326)
```

```{r}
library(leaflet)
leaflet(my_sf) %>%
  addProviderTiles(providers$CartoDB.DarkMatter) %>%  # Light-themed basemap
  addPolylines(color = "lightblue", weight = 3, opacity = 0.8)
```
